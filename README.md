# AES Encryption in C++

## Table of contents

1. Introduction
2. Supported input
3. AES-specific operations
4. AES-128 structure
5. Project configuration
6. Compilation and execution
7. Relevant numerical values

### Introduction 

This project implements AES encryption in C++. It functions for the AES-128 version, which entails that the key to be used is 128 bits.
The key can therefore be visualized as a 4x4 quadratic matrix. Round keys (which will be introduced in section 3) are also 4x4 matrices.
The programming language of choice is C++ because of its good performance over computationally expensive tasks such as **encryption**. 
C++ also facilitates quick bitwise operations (which are used in the Galois multiplication employed by AES).  

### Supported input

The input is expected to be raw bytes. For simplicity, the project does not account for input consisting of strings. 
However, that can be easily accommodated by adding a stringToByte() functionality that takes the contents of a string and creates a table with the corresponding bytes.
- First 16 bytes are the key bytes.
- After the first 16 bytes have been parsed, every new 16-byte batch is considered a block to be encrypted.

### AES-specific operations

Firstly, let us define keyExpansion, which is performed on the initial key, rather than the block.
- Key expansion: given the key, expand it into 11 new round keys to increase security. This is done by using R_CON (see section 7 "Relevant numerical values") and performing certain XOR operations on the columns of the previously derived key.
- The first key is equal to the initial key, then the 2nd key is derived using the first, 3rd using the second, etc. until all 11 keys are formed

Let us define the operations performed on an arbitrary block of the input.
- subBytes: given S_BOX (see section 7 "Relevant numerical values"), for every element in block, look up its corresponding S_BOX value and assign that value to it.
- shiftRows: For i form 0 to 3, on the i-th row of the block, shift the elements i cells to the left.
- mixColumns: given the Galois matrix (see section 7 "Relevant numerical values"), multiply it in the Galois field **GF(256)** with every column in the block. 
- addRoundKey: XOR the block with its corresponding round key. addRoundKey also takes the corresponding round key as a parameter, along with the block.

### AES-128 structure

Since we are treating the 128-bit version of AES, there will be a total of 11 rounds.
- The initial round: only perform addRoundKey on the block and the first round key. Let us denote this as round 0.
Then, 9 full rounds, all 4 of the operations defined above are performed. For round i (i from 1 to 9):
- subBytes(block)
- shiftRows(block)
- mixColumns(block)
- addRoundKey(block, i-th round key)
In the last round, perform all operations except for mixColumns. Last round looks as follows:
- subBytes(block)
- shiftRows(block)
- addROundKey(block, i-th round key)

### Project configuration

Clone the repository.
`git clone https://github.com/sevnastase/Advanced-Encryption-Standard-128.git`.
Navigate to directory.
`cd Advanced-Encryption-Standard-128`.


### Compilation and execution

Ensure GCC compiler is installed. This project was compiled using G++. To verify G++ is installed on system, run: `g++ --version`.
In terminal, run the following commands:
`g++ <source_file_name> -o <output_file_name>` (to compile the program using G++ compiler).
`.\<path_to_output_file>` (execute compiled program on system).
Then, provide necessary input (in raw bytes).

### Relevant numerical values

- S_BOX is a 16 by 16 matrix (one row and one column for every possible hex value).
  
S_BOX = {
    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
};
    
- R_CON is an array of 10 hex values.
R_CON = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36};

- The Galois Matrix is a quadratic matrix comprised only of values of 0x01, 0x02, 0x03, namely
{
  {0x02, 0x03, 0x01, 0x01},
  {0x01, 0x02, 0x03, 0x01},
  {0x01, 0x01, 0x02, 0x03},
  {0x03, 0x01, 0x01, 0x02}
}.

